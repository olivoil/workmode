#!/usr/bin/env bash
# workmode-run — Core runner called by triggers
# Reads trigger config, checks dedup/cooldown, runs claude -p, logs to JSONL, sends notifications.
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")/.." && pwd)"
source "$SCRIPT_DIR/lib/config.sh"
source "$SCRIPT_DIR/lib/notify.sh"

STATE_DIR="$(config_state_dir)"
HISTORY_FILE="$STATE_DIR/history.jsonl"
LOCK_DIR="$STATE_DIR/locks"
LOG_DIR="$STATE_DIR/logs"

mkdir -p "$STATE_DIR" "$LOCK_DIR" "$LOG_DIR"

usage() {
    echo "Usage: workmode-run --trigger <name> [--file <path>]"
    exit 1
}

# Parse args
TRIGGER_NAME=""
FILE_PATH=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --trigger) TRIGGER_NAME="$2"; shift 2 ;;
        --file)    FILE_PATH="$2"; shift 2 ;;
        *)         usage ;;
    esac
done

[[ -z "$TRIGGER_NAME" ]] && usage

# Load trigger config
eval "$(config_trigger "$TRIGGER_NAME")" || {
    echo "Error: trigger '$TRIGGER_NAME' not found in config" >&2
    exit 1
}

SKILL="${TRIGGER_skill:-}"
PROMPT_TEXT="${TRIGGER_prompt:-}"
PERMISSIONS="${TRIGGER_permissions:-default}"
WORKING_DIR="${TRIGGER_working_dir:-$PWD}"
COOLDOWN="${TRIGGER_cooldown:-0}"
CHECK_CMD="${TRIGGER_check:-}"
CRON_EXPR="${TRIGGER_cron:-}"
TYPE="${TRIGGER_type:-timer}"
RETRY="${TRIGGER_retry:-never}"          # never | on_error | always
RETRY_MAX="${TRIGGER_retry_max:-3}"      # 0 = unlimited
RETRY_DELAY="${TRIGGER_retry_delay:-30}" # seconds between retries

# Either skill or prompt must be set
[[ -z "$SKILL" && -z "$PROMPT_TEXT" ]] && {
    echo "Error: trigger '$TRIGGER_NAME' has no skill or prompt defined" >&2
    exit 1
}

# Display label for notifications/logs — prefer skill name, fall back to trigger name
DISPLAY_LABEL="${SKILL:-$TRIGGER_NAME}"

# Expand working_dir
WORKING_DIR="${WORKING_DIR/#\~/$HOME}"

# --- Dedup: check if already running ---
LOCK_FILE="$LOCK_DIR/${TRIGGER_NAME}.lock"
if [[ -f "$LOCK_FILE" ]]; then
    LOCK_PID="$(cat "$LOCK_FILE" 2>/dev/null)"
    if kill -0 "$LOCK_PID" 2>/dev/null; then
        echo "Trigger '$TRIGGER_NAME' already running (pid $LOCK_PID), skipping"
        exit 0
    fi
    # Stale lock
    rm -f "$LOCK_FILE"
fi

# --- Max parallel check ---
MAX_PARALLEL="$(config_max_parallel)"
RUNNING_COUNT="$(find "$LOCK_DIR" -name '*.lock' -exec sh -c 'kill -0 "$(cat "$1")" 2>/dev/null && echo 1' _ {} \; | wc -l)"
if (( RUNNING_COUNT >= MAX_PARALLEL )); then
    echo "Max parallel ($MAX_PARALLEL) reached, skipping trigger '$TRIGGER_NAME'"
    exit 0
fi

# --- Cooldown check ---
if (( COOLDOWN > 0 )); then
    LAST_RUN="$(grep "\"trigger\":\"${TRIGGER_NAME}\"" "$HISTORY_FILE" 2>/dev/null | grep '"status":"completed"' | tail -1 | grep -oP '"started":"[^"]*"' | grep -oP '\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}' || true)"
    if [[ -n "$LAST_RUN" ]]; then
        LAST_EPOCH="$(date -d "$LAST_RUN" +%s 2>/dev/null || echo 0)"
        NOW_EPOCH="$(date +%s)"
        ELAPSED=$(( NOW_EPOCH - LAST_EPOCH ))
        if (( ELAPSED < COOLDOWN )); then
            echo "Cooldown active for '$TRIGGER_NAME' (${ELAPSED}s < ${COOLDOWN}s), skipping"
            exit 0
        fi
    fi
fi

# --- Pre-check command (e.g., check if there are PRs to review) ---
if [[ -n "$CHECK_CMD" ]]; then
    CHECK_RESULT="$(eval "$CHECK_CMD" 2>/dev/null || echo "0")"
    if [[ "$CHECK_RESULT" == "0" || -z "$CHECK_RESULT" ]]; then
        echo "Check command returned 0/empty for '$TRIGGER_NAME', skipping"
        exit 0
    fi
fi

# --- Generate session ID ---
# Full ID for uniqueness, short ID for human use (trigger-xxxx)
FULL_ID="wm-$(date +%s)-$$"
SHORT_ID="${TRIGGER_NAME}-$(printf '%04x' $(( (RANDOM * RANDOM) % 65536 )) )"
SESSION_ID="$FULL_ID"

# --- Write lock ---
echo $$ > "$LOCK_FILE"
trap 'rm -f "$LOCK_FILE"' EXIT

# --- Log: started ---
STARTED="$(date -Iseconds)"
log_entry() {
    local status="$1"
    shift
    local entry
    entry="$(printf '{"id":"%s","short":"%s","trigger":"%s","label":"%s","working_dir":"%s","started":"%s","status":"%s"%s}' \
        "$SESSION_ID" "$SHORT_ID" "$TRIGGER_NAME" "$DISPLAY_LABEL" "$WORKING_DIR" "$STARTED" "$status" "$*")"
    echo "$entry" >> "$HISTORY_FILE"
}

log_entry "running" ",\"pid\":$$"
notify_started "$DISPLAY_LABEL" "$TRIGGER_NAME"

# --- Build claude command ---
# Use -p (print mode) for non-interactive execution.
# Sessions are persisted by default and can be resumed with --resume.
CLAUDE_CMD=(claude -p)

case "$PERMISSIONS" in
    skip)     CLAUDE_CMD+=(--dangerously-skip-permissions) ;;
    readonly) CLAUDE_CMD+=(--permission-mode bypassPermissions) ;;
    # default: no extra flags
esac

CLAUDE_CMD+=(--output-format stream-json --verbose)

# Build the prompt — use explicit prompt if set, otherwise the skill name
PROMPT="${PROMPT_TEXT:-$SKILL}"
if [[ -n "$FILE_PATH" ]]; then
    if [[ "$PROMPT" == *'{file}'* ]]; then
        # Replace {file} placeholder with actual path
        PROMPT="${PROMPT//\{file\}/$FILE_PATH}"
    else
        # Append file path
        PROMPT="$PROMPT $FILE_PATH"
    fi
fi

# --- Run claude (with retry loop) ---
ATTEMPT=0
FINAL_EXIT_CODE=0

cd "$WORKING_DIR"

while true; do
    (( ATTEMPT++ ))

    SESSION_LOG="$LOG_DIR/${SESSION_ID}.log"
    CLAUDE_SESSION_ID=""
    EXIT_CODE=0

    if (( ATTEMPT > 1 )); then
        # Generate new IDs for retry attempts
        SESSION_ID="wm-$(date +%s)-$$"
        SHORT_ID="${TRIGGER_NAME}-$(printf '%04x' $(( (RANDOM * RANDOM) % 65536 )) )"
        SESSION_LOG="$LOG_DIR/${SESSION_ID}.log"
        STARTED="$(date -Iseconds)"
        log_entry "running" ",\"pid\":$$,\"attempt\":${ATTEMPT}"
        notify_started "$DISPLAY_LABEL" "$TRIGGER_NAME (retry $((ATTEMPT - 1)))"
    fi

    # Unset CLAUDECODE to allow running from within a Claude session
    # Use stdbuf to disable output buffering so tail -f works on the log file
    stdbuf -oL env -u CLAUDECODE "${CLAUDE_CMD[@]}" "$PROMPT" > "$SESSION_LOG" 2>&1 || EXIT_CODE=$?

    # Try to extract the Claude session ID from stream-json output
    CLAUDE_SESSION_ID="$(grep -oP '"session_id"\s*:\s*"[^"]*"' "$SESSION_LOG" | head -1 | grep -oP '"[^"]*"$' | tr -d '"' || true)"

    # Calculate duration
    ENDED="$(date -Iseconds)"
    DURATION=$(( $(date +%s) - $(date -d "$STARTED" +%s) ))

    # --- Determine status and log ---
    EXTRA=",\"duration\":${DURATION}"
    [[ -n "$CLAUDE_SESSION_ID" ]] && EXTRA="${EXTRA},\"session_id\":\"${CLAUDE_SESSION_ID}\""
    [[ -n "$FILE_PATH" ]] && EXTRA="${EXTRA},\"file\":\"${FILE_PATH}\""
    (( ATTEMPT > 1 )) && EXTRA="${EXTRA},\"attempt\":${ATTEMPT}"

    if (( EXIT_CODE == 0 )); then
        log_entry "completed" "$EXTRA"
        notify_completed "$DISPLAY_LABEL" "$TRIGGER_NAME" "$DURATION"
        FINAL_EXIT_CODE=0
        break
    elif (( EXIT_CODE == 2 )); then
        # Exit code 2 typically means permission/interaction needed — don't retry
        log_entry "stuck" "$EXTRA"
        notify_stuck "$DISPLAY_LABEL" "$TRIGGER_NAME" "${CLAUDE_SESSION_ID:-$SESSION_ID}"
        FINAL_EXIT_CODE=$EXIT_CODE
        break
    else
        # Capture first line of log as error hint if log is small (likely a startup error)
        local error_hint=""
        if [[ -f "$SESSION_LOG" ]]; then
            local log_size
            log_size="$(wc -c < "$SESSION_LOG")"
            if (( log_size > 0 && log_size < 500 )); then
                error_hint="$(head -1 "$SESSION_LOG" | tr '"' "'" | head -c 200)"
            fi
        fi
        if [[ -n "$error_hint" ]]; then
            log_entry "error" "${EXTRA},\"exit_code\":${EXIT_CODE},\"error\":\"${error_hint}\""
        else
            log_entry "error" "${EXTRA},\"exit_code\":${EXIT_CODE}"
        fi
        FINAL_EXIT_CODE=$EXIT_CODE
    fi

    # --- Retry decision ---
    local should_retry=false 2>/dev/null || true
    should_retry=false
    case "$RETRY" in
        on_error) (( EXIT_CODE != 0 )) && should_retry=true ;;
        always)   should_retry=true ;;
        *)        should_retry=false ;;  # "never" or unset
    esac

    if ! $should_retry; then
        notify_error "$DISPLAY_LABEL" "$TRIGGER_NAME" "$SESSION_ID"
        break
    fi

    if (( RETRY_MAX > 0 && ATTEMPT >= RETRY_MAX )); then
        echo "Max retries ($RETRY_MAX) reached for '$TRIGGER_NAME'"
        notify_error "$DISPLAY_LABEL" "$TRIGGER_NAME (max retries)" "$SESSION_ID"
        break
    fi

    echo "Retrying '$TRIGGER_NAME' in ${RETRY_DELAY}s (attempt $ATTEMPT)..."
    sleep "$RETRY_DELAY"
done

exit $FINAL_EXIT_CODE
