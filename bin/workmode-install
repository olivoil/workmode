#!/usr/bin/env bash
# workmode-install — Reads config → generates systemd user timers + watcher service
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")/.." && pwd)"
source "$SCRIPT_DIR/lib/config.sh"

BIN_DIR="$SCRIPT_DIR/bin"
STATE_DIR="$(config_state_dir)"
LOG_DIR="$STATE_DIR/logs"
UNIT_PREFIX="workmode-trigger-"
WATCHER_SERVICE="workmode-watcher"
SYSTEMD_DIR="$HOME/.config/systemd/user"

mkdir -p "$STATE_DIR" "$LOG_DIR" "$SYSTEMD_DIR"

# --- Timer triggers → systemd timers ---

install_timers() {
    echo "Installing systemd timers..."

    for name in $(config_triggers_by_type "timer"); do
        local label cron_expr interval on_calendar

        # Explicit cron expression takes priority over interval
        cron_expr="$(config_trigger_field "$name" "cron" || true)"
        if [[ -n "$cron_expr" ]]; then
            # Convert cron to OnCalendar format
            on_calendar="$(cron_to_oncalendar "$cron_expr")"
        else
            interval="$(config_trigger_field "$name" "interval")"
            on_calendar="$(interval_to_oncalendar "$interval")"
        fi

        label="$(config_trigger_field "$name" "skill" || true)"
        [[ -z "$label" ]] && label="$(config_trigger_field "$name" "prompt" | head -c 40 || echo "$name")"

        local unit_name="${UNIT_PREFIX}${name}"

        # Generate .service unit
        cat > "$SYSTEMD_DIR/${unit_name}.service" <<SERVICE
[Unit]
Description=Workmode trigger: ${name}

[Service]
Type=oneshot
ExecStart=${BIN_DIR}/workmode-run --trigger ${name}
StandardOutput=append:${LOG_DIR}/${name}.log
StandardError=append:${LOG_DIR}/${name}.log
SERVICE

        # Generate .timer unit
        cat > "$SYSTEMD_DIR/${unit_name}.timer" <<TIMER
[Unit]
Description=Workmode timer: ${name}

[Timer]
${on_calendar}
Persistent=true

[Install]
WantedBy=timers.target
TIMER

        echo "  + $name: $on_calendar → $label"
    done

    systemctl --user daemon-reload
    echo "Timers installed."
}

uninstall_timers() {
    echo "Removing systemd timers..."

    for unit_file in "$SYSTEMD_DIR"/${UNIT_PREFIX}*.timer; do
        [[ -f "$unit_file" ]] || continue
        local unit_name
        unit_name="$(basename "$unit_file")"
        local service_name="${unit_name%.timer}.service"

        systemctl --user stop "$unit_name" 2>/dev/null || true
        systemctl --user disable "$unit_name" 2>/dev/null || true
        rm -f "$SYSTEMD_DIR/$unit_name" "$SYSTEMD_DIR/$service_name"
        echo "  - removed $unit_name"
    done

    systemctl --user daemon-reload
    echo "Timers removed."
}

enable_timers() {
    for name in $(config_triggers_by_type "timer"); do
        local unit_name="${UNIT_PREFIX}${name}.timer"
        systemctl --user enable "$unit_name" 2>/dev/null || true
        systemctl --user start "$unit_name" 2>/dev/null || true
    done
}

disable_timers() {
    for unit_file in "$SYSTEMD_DIR"/${UNIT_PREFIX}*.timer; do
        [[ -f "$unit_file" ]] || continue
        local unit_name
        unit_name="$(basename "$unit_file")"
        systemctl --user stop "$unit_name" 2>/dev/null || true
        systemctl --user disable "$unit_name" 2>/dev/null || true
    done
}

# --- File triggers → inotifywait watcher service ---

install_watcher_service() {
    local has_file_triggers=false

    local watch_dirs=()

    for name in $(config_triggers_by_type "file"); do
        has_file_triggers=true
        local watch_dir
        watch_dir="$(config_trigger_field "$name" "watch")"
        watch_dirs+=("$watch_dir")
    done

    if ! $has_file_triggers; then
        echo "No file triggers configured, skipping watcher service."
        if systemctl --user is-active "$WATCHER_SERVICE" &>/dev/null; then
            systemctl --user stop "$WATCHER_SERVICE"
            systemctl --user disable "$WATCHER_SERVICE"
        fi
        rm -f "$SYSTEMD_DIR/${WATCHER_SERVICE}.service"
        return
    fi

    echo "Installing watcher service..."

    # Build the watcher script
    local watcher_script="$STATE_DIR/watcher.sh"
    cat > "$watcher_script" <<'WATCHER_HEADER'
#!/usr/bin/env bash
set -euo pipefail
WATCHER_HEADER

    cat >> "$watcher_script" <<WATCHER_CONFIG
SCRIPT_DIR="$SCRIPT_DIR"
source "\$SCRIPT_DIR/lib/config.sh"
BIN_DIR="$BIN_DIR"
WATCHER_CONFIG

    # Build inotifywait command with all watch directories
    local inotify_dirs=""
    for dir in "${watch_dirs[@]}"; do
        inotify_dirs+=" $(printf '%q' "$dir")"
    done

    cat >> "$watcher_script" <<WATCHER_BODY

inotifywait -m -r --format '%w%f' -e close_write -e moved_to${inotify_dirs} |
while IFS= read -r filepath; do
    filename="\$(basename "\$filepath")"
WATCHER_BODY

    for name in $(config_triggers_by_type "file"); do
        local pattern watch_dir settle
        pattern="$(config_trigger_field "$name" "pattern")"
        watch_dir="$(config_trigger_field "$name" "watch")"
        settle="$(config_trigger_field "$name" "settle" 2>/dev/null || echo "0")"

        if [[ "$settle" -gt 0 ]] 2>/dev/null; then
            cat >> "$watcher_script" <<MATCH_BLOCK
    # Trigger: $name (settle: ${settle}s — wait for file to stop changing)
    if [[ "\$filepath" == ${watch_dir}/* ]] && [[ "\$filename" == $pattern ]]; then
        (
            while true; do
                size_before=\$(stat -c%s "\$filepath" 2>/dev/null || echo 0)
                sleep $settle
                size_after=\$(stat -c%s "\$filepath" 2>/dev/null || echo 0)
                [[ "\$size_before" == "\$size_after" ]] && break
            done
            "$BIN_DIR/workmode-run" --trigger "$name" --file "\$filepath"
        ) &
        continue
    fi
MATCH_BLOCK
        else
            cat >> "$watcher_script" <<MATCH_BLOCK
    # Trigger: $name
    if [[ "\$filepath" == ${watch_dir}/* ]] && [[ "\$filename" == $pattern ]]; then
        "$BIN_DIR/workmode-run" --trigger "$name" --file "\$filepath" &
        continue
    fi
MATCH_BLOCK
        fi
    done

    echo "done" >> "$watcher_script"
    chmod +x "$watcher_script"

    cat > "$SYSTEMD_DIR/${WATCHER_SERVICE}.service" <<SERVICE
[Unit]
Description=Workmode file watcher

[Service]
Type=simple
ExecStart=$watcher_script
Restart=on-failure
RestartSec=5

[Install]
WantedBy=default.target
SERVICE

    systemctl --user daemon-reload
    echo "Watcher service installed."
}

uninstall_watcher_service() {
    if systemctl --user is-active "$WATCHER_SERVICE" &>/dev/null; then
        systemctl --user stop "$WATCHER_SERVICE"
    fi
    if systemctl --user is-enabled "$WATCHER_SERVICE" &>/dev/null; then
        systemctl --user disable "$WATCHER_SERVICE"
    fi
    rm -f "$SYSTEMD_DIR/${WATCHER_SERVICE}.service"
    systemctl --user daemon-reload 2>/dev/null || true
    echo "Watcher service removed."
}

# --- Config watcher → auto-reinstall on config change ---

CONFIG_WATCHER="workmode-config-watcher"

install_config_watcher() {
    echo "Installing config watcher..."

    cat > "$SYSTEMD_DIR/${CONFIG_WATCHER}.service" <<SERVICE
[Unit]
Description=Workmode config auto-reinstall

[Service]
Type=oneshot
ExecStart=${BIN_DIR}/workmode-install install
SERVICE

    cat > "$SYSTEMD_DIR/${CONFIG_WATCHER}.path" <<PATH
[Unit]
Description=Watch workmode config for changes

[Path]
PathModified=${WORKMODE_CONFIG}

[Install]
WantedBy=default.target
PATH

    systemctl --user daemon-reload
    echo "Config watcher installed."
}

uninstall_config_watcher() {
    systemctl --user stop "${CONFIG_WATCHER}.path" 2>/dev/null || true
    systemctl --user disable "${CONFIG_WATCHER}.path" 2>/dev/null || true
    rm -f "$SYSTEMD_DIR/${CONFIG_WATCHER}.path" "$SYSTEMD_DIR/${CONFIG_WATCHER}.service"
    systemctl --user daemon-reload 2>/dev/null || true
    echo "Config watcher removed."
}

# --- Claude Code skill symlink ---

install_skill() {
    local skill_dir="$HOME/.claude/skills/workmode"
    local skill_src="$SCRIPT_DIR/skill"

    if [[ -d "$skill_src" ]]; then
        mkdir -p "$(dirname "$skill_dir")"
        if [[ -L "$skill_dir" ]]; then
            local current_target
            current_target="$(readlink "$skill_dir")"
            if [[ "$current_target" == "$skill_src" ]]; then
                return  # Already correct
            fi
            rm -f "$skill_dir"
        elif [[ -d "$skill_dir" ]]; then
            echo "  Skill directory exists and is not a symlink: $skill_dir" >&2
            return
        fi
        ln -sf "$skill_src" "$skill_dir"
        echo "Skill installed: $skill_dir → $skill_src"
    fi
}

uninstall_skill() {
    local skill_dir="$HOME/.claude/skills/workmode"
    if [[ -L "$skill_dir" ]]; then
        rm -f "$skill_dir"
        echo "Skill symlink removed."
    fi
}

# --- Shell completions ---

install_completions() {
    local workmode_bin="$BIN_DIR/workmode"

    # Bash completions
    local bash_comp_dir="$HOME/.local/share/bash-completion/completions"
    mkdir -p "$bash_comp_dir"
    bash "$workmode_bin" completions bash > "$bash_comp_dir/workmode"
    echo "Bash completions installed: $bash_comp_dir/workmode"

    # Zsh completions (if zsh config dir exists)
    if [[ -f "$HOME/.zshrc" ]]; then
        local zsh_comp_dir="$HOME/.local/share/zsh/site-functions"
        mkdir -p "$zsh_comp_dir"
        bash "$workmode_bin" completions zsh > "$zsh_comp_dir/_workmode"
        # Ensure the dir is in fpath
        if ! grep -q 'workmode.*fpath\|site-functions.*fpath\|fpath.*site-functions' "$HOME/.zshrc" 2>/dev/null; then
            if ! grep -q "$zsh_comp_dir" "$HOME/.zshrc" 2>/dev/null; then
                echo "Zsh completions installed: $zsh_comp_dir/_workmode"
                echo "  Add to .zshrc: fpath=($zsh_comp_dir \$fpath)"
            fi
        else
            echo "Zsh completions installed: $zsh_comp_dir/_workmode"
        fi
    fi

    # Fish completions (if fish config dir exists)
    if [[ -d "$HOME/.config/fish" ]]; then
        local fish_comp_dir="$HOME/.config/fish/completions"
        mkdir -p "$fish_comp_dir"
        bash "$workmode_bin" completions fish > "$fish_comp_dir/workmode.fish"
        echo "Fish completions installed: $fish_comp_dir/workmode.fish"
    fi
}

uninstall_completions() {
    rm -f "$HOME/.local/share/bash-completion/completions/workmode"
    rm -f "$HOME/.local/share/zsh/site-functions/_workmode"
    rm -f "$HOME/.config/fish/completions/workmode.fish"
    echo "Shell completions removed."
}

# --- Helpers: interval/cron → OnCalendar ---

# Convert interval like "2h", "15m" to systemd timer directives
# Returns two lines: OnActiveSec (first run) + OnUnitActiveSec (repeat)
interval_to_oncalendar() {
    local interval="$1"
    local num="${interval%[hms]*}"
    local unit="${interval##*[0-9]}"
    local sd_unit

    case "$unit" in
        h) sd_unit="${num}h" ;;
        m) sd_unit="${num}min" ;;
        s) sd_unit="${num}s" ;;
        *)  sd_unit="${num}min" ;;
    esac

    # OnActiveSec triggers the first run after the timer is started
    # OnUnitActiveSec repeats after each service activation
    printf "OnActiveSec=%s\nOnUnitActiveSec=%s" "$sd_unit" "$sd_unit"
}

# Convert 5-field cron expression to systemd OnCalendar
# e.g. "45 8 * * 1-5" → "OnCalendar=Mon..Fri *-*-* 08:45:00"
cron_to_oncalendar() {
    local cron="$1"
    local minute hour dom month dow
    read -r minute hour dom month dow <<< "$cron"

    # Day of week mapping
    local sd_dow="*"
    if [[ "$dow" != "*" ]]; then
        sd_dow="$(echo "$dow" | sed \
            -e 's/0/Sun/g' -e 's/1/Mon/g' -e 's/2/Tue/g' \
            -e 's/3/Wed/g' -e 's/4/Thu/g' -e 's/5/Fri/g' \
            -e 's/6/Sat/g' -e 's/7/Sun/g' -e 's/-/../g')"
    fi

    # Pad hour/minute
    [[ "$hour" != "*" && ${#hour} -eq 1 ]] && hour="0${hour}"
    [[ "$minute" != "*" && ${#minute} -eq 1 ]] && minute="0${minute}"

    local date_part="*-${month}-${dom}"
    [[ "$month" == "*" && "$dom" == "*" ]] && date_part="*-*-*"

    local calendar="${sd_dow} ${date_part} ${hour}:${minute}:00"
    # Clean up: remove leading "* " if dow is *
    [[ "$sd_dow" == "*" ]] && calendar="${date_part} ${hour}:${minute}:00"

    echo "OnCalendar=${calendar}"
}

# --- Main ---

case "${1:-install}" in
    install)
        install_timers
        install_watcher_service
        install_config_watcher
        install_skill
        install_completions
        # Build Go TUI if go is available
        if command -v go &>/dev/null && [[ -f "$SCRIPT_DIR/tui/go.mod" ]]; then
            echo "Building TUI binary..."
            (cd "$SCRIPT_DIR/tui" && go build -o "$BIN_DIR/workmode-tui" .) && echo "  workmode-tui built" || echo "  TUI build skipped (go build failed)"
        fi
        echo ""
        echo "Run 'workmode on' to activate triggers."
        ;;
    uninstall)
        uninstall_timers
        uninstall_watcher_service
        uninstall_config_watcher
        uninstall_skill
        uninstall_completions
        ;;
    enable)
        enable_timers
        ;;
    disable)
        disable_timers
        ;;
    *)
        echo "Usage: workmode-install [install|uninstall|enable|disable]"
        exit 1
        ;;
esac
