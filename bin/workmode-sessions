#!/usr/bin/env bash
# workmode-sessions â€” List session history, filter, resume
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")/.." && pwd)"
source "$SCRIPT_DIR/lib/config.sh"

STATE_DIR="$(config_state_dir)"
HISTORY_FILE="$STATE_DIR/history.jsonl"
LOG_DIR="$STATE_DIR/logs"

# Colors (disabled when piping)
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    RESET='\033[0m'
    BOLD='\033[1m'
else
    RED='' GREEN='' YELLOW='' BLUE='' RESET='' BOLD=''
fi

usage() {
    cat <<EOF
Usage: workmode-sessions [OPTIONS] [COMMAND]

Commands:
  list              List recent sessions (default)
  logs <id>         Show full output log of a session
  tail <id>         Follow a running session's log (like tail -f)
  resume <id>       Resume a session with claude --resume

Options:
  --running         Show only running sessions
  --stuck           Show only stuck sessions
  --completed       Show only completed sessions
  --all             Show all sessions (default: last 20)
  -n <count>        Number of sessions to show
  --json            Output raw JSON

EOF
    exit 0
}

# Extract JSON field value (simple, no jq dependency)
json_field() {
    local json="$1" field="$2"
    local result
    result="$(echo "$json" | grep -oP "\"${field}\"\\s*:\\s*\"[^\"]*\"" | head -1 | grep -oP '"[^"]*"$' | tr -d '"' || true)"
    echo "$result"
}

json_field_num() {
    local json="$1" field="$2"
    local result
    result="$(echo "$json" | grep -oP "\"${field}\"\\s*:\\s*[0-9]+" | head -1 | grep -oP '[0-9]+$' || true)"
    echo "$result"
}

format_duration() {
    local seconds="$1"
    [[ -z "$seconds" || "$seconds" == "0" ]] && echo "â€”" && return
    if (( seconds < 60 )); then
        echo "${seconds}s"
    elif (( seconds < 3600 )); then
        echo "$(( seconds / 60 ))m"
    else
        echo "$(( seconds / 3600 ))h$(( (seconds % 3600) / 60 ))m"
    fi
}

format_time() {
    local iso_time="$1"
    [[ -z "$iso_time" ]] && echo "â€”" && return

    local today
    today="$(date +%Y-%m-%d)"
    local day="${iso_time%%T*}"
    local time="${iso_time#*T}"
    time="${time%%[-+]*}"  # strip timezone
    time="${time%:*}"      # HH:MM

    if [[ "$day" == "$today" ]]; then
        echo "$time today"
    else
        echo "$time ${day#*-}"  # MM-DD
    fi
}

status_icon() {
    local icon text color
    case "$1" in
        completed) icon="âœ…"; text="done";  color="$GREEN" ;;
        running)   icon="ðŸ”„"; text="run";   color="$BLUE" ;;
        stuck)     icon="â¸";  text="stuck"; color="$YELLOW" ;;
        error)     icon="âŒ"; text="err";   color="$RED" ;;
        *)         icon="?";  text="$1";    color="$RESET" ;;
    esac
    # Pad the visible text to 8 chars, then wrap in color codes
    printf "%s %b%-7s%b" "$icon" "$color" "$text" "$RESET"
}

# --- Parse args ---
FILTER=""
COUNT=20
COMMAND="list"
OUTPUT="table"

while [[ $# -gt 0 ]]; do
    case "$1" in
        resume)
            COMMAND="resume"
            shift
            RESUME_ID="${1:-}"
            shift || true
            ;;
        logs|log)
            COMMAND="logs"
            shift
            TARGET_ID="${1:-}"
            shift || true
            ;;
        tail)
            COMMAND="tail"
            shift
            TARGET_ID="${1:-}"
            shift || true
            ;;
        list)      COMMAND="list"; shift ;;
        --running)   FILTER="running"; shift ;;
        --stuck)     FILTER="stuck"; shift ;;
        --completed) FILTER="completed"; shift ;;
        --all)       COUNT=0; shift ;;
        -n)          COUNT="$2"; shift 2 ;;
        --json)      OUTPUT="json"; shift ;;
        --help|-h)   usage ;;
        *)
            # If it looks like a session ID (short or full), treat as logs
            if [[ "$1" =~ ^wm- ]] || [[ "$1" =~ ^[a-z]+-[0-9a-f]{4}$ ]]; then
                COMMAND="logs"
                TARGET_ID="$1"
                shift
            else
                echo "Unknown option: $1" >&2
                usage
            fi
            ;;
    esac
done

# --- Commands ---

cmd_list() {
    if [[ ! -f "$HISTORY_FILE" ]]; then
        echo "No sessions yet."
        exit 0
    fi

    # Get the latest status for each session (last line per ID wins)
    local sessions
    sessions="$(tac "$HISTORY_FILE")"

    # Filter to final status per session (deduplicate by id)
    local seen_ids=()
    local lines=()

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        # Skip malformed lines (e.g. partial writes)
        [[ "$line" == *'"id"'* ]] || continue
        local id
        id="$(json_field "$line" "id")"
        [[ -z "$id" ]] && continue

        # Skip if already seen this id
        local already_seen=false
        for seen in "${seen_ids[@]+"${seen_ids[@]}"}"; do
            if [[ "$seen" == "$id" ]]; then
                already_seen=true
                break
            fi
        done
        $already_seen && continue

        seen_ids+=("$id")

        # Apply filter
        if [[ -n "$FILTER" ]]; then
            local status
            status="$(json_field "$line" "status")"
            [[ "$status" != "$FILTER" ]] && continue
        fi

        lines+=("$line")

        # Count limit
        if (( COUNT > 0 && ${#lines[@]} >= COUNT )); then
            break
        fi
    done <<< "$sessions"

    if [[ ${#lines[@]} -eq 0 ]]; then
        echo "No sessions found${FILTER:+ with status '$FILTER'}."
        exit 0
    fi

    if [[ "$OUTPUT" == "json" ]]; then
        printf '%s\n' "${lines[@]}"
        return
    fi

    # Table header â€” widths: status=10, trigger=14, label=22, started=14, duration=10, id=rest
    printf "${BOLD}%-10s %-14s %-22s %-14s %-10s %s${RESET}\n" \
        "STATUS" "TRIGGER" "LABEL" "STARTED" "DURATION" "ID"

    for line in "${lines[@]}"; do
        local status trigger label started duration short_id
        status="$(json_field "$line" "status")"
        trigger="$(json_field "$line" "trigger")"
        label="$(json_field "$line" "label")"
        started="$(json_field "$line" "started")"
        duration="$(json_field_num "$line" "duration")"
        short_id="$(json_field "$line" "short")"
        # Fall back to full id for older entries without short id
        [[ -z "$short_id" ]] && short_id="$(json_field "$line" "id")"

        # status_icon self-pads to ~10 visible chars, so print it raw then the rest
        printf "%s %-14s %-22s %-14s %-10s %s\n" \
            "$(status_icon "$status")" \
            "$trigger" \
            "$label" \
            "$(format_time "$started")" \
            "$(format_duration "$duration")" \
            "$short_id"
    done
}

# Resolve a short or full session ID to the history line
# Usage: resolve_session <id>
# Prints the matching history line (last entry for that session)
resolve_session() {
    local lookup="$1"

    # Try full ID first
    local match
    match="$(grep "\"id\":\"${lookup}\"" "$HISTORY_FILE" 2>/dev/null | tail -1 || true)"
    if [[ -n "$match" ]]; then
        echo "$match"
        return 0
    fi

    # Try short ID
    match="$(grep "\"short\":\"${lookup}\"" "$HISTORY_FILE" 2>/dev/null | tail -1 || true)"
    if [[ -n "$match" ]]; then
        echo "$match"
        return 0
    fi

    return 1
}

cmd_resume() {
    if [[ -z "${RESUME_ID:-}" ]]; then
        echo "Usage: workmode sessions resume <id>" >&2
        exit 1
    fi

    local session_line
    session_line="$(resolve_session "$RESUME_ID")" || {
        echo "Session '$RESUME_ID' not found." >&2
        exit 1
    }

    local claude_session_id
    claude_session_id="$(json_field "$session_line" "session_id")"

    if [[ -z "$claude_session_id" ]]; then
        echo "No Claude session ID found for '$RESUME_ID'." >&2
        echo "The session may not have started successfully."
        exit 1
    fi

    # Resume must run from the same working directory as the original session
    local working_dir
    working_dir="$(json_field "$session_line" "working_dir")"
    if [[ -n "$working_dir" && -d "$working_dir" ]]; then
        echo "Resuming in: $working_dir"
        cd "$working_dir"
    fi

    echo "Resuming Claude session: $claude_session_id"
    exec claude --resume "$claude_session_id"
}

find_session_log() {
    local lookup="$1"

    # Direct log file by full ID
    if [[ -f "$LOG_DIR/${lookup}.log" ]]; then
        echo "$LOG_DIR/${lookup}.log"
        return 0
    fi

    # Resolve short/full ID to get the full ID for the log file
    local session_line
    session_line="$(resolve_session "$lookup")" || return 1

    local full_id
    full_id="$(json_field "$session_line" "id")"
    if [[ -n "$full_id" && -f "$LOG_DIR/${full_id}.log" ]]; then
        echo "$LOG_DIR/${full_id}.log"
        return 0
    fi

    return 1
}

# Parse stream-json log into readable output
format_session_log() {
    local log_file="$1"

    while IFS= read -r line; do
        # Skip empty lines
        [[ -z "$line" ]] && continue

        # Try to parse stream-json events
        local type
        type="$(echo "$line" | grep -oP '"type"\s*:\s*"[^"]*"' | grep -oP '"[^"]*"$' | tr -d '"' 2>/dev/null || true)"

        case "$type" in
            assistant)
                # Extract text content from assistant messages
                local text
                text="$(echo "$line" | grep -oP '"content"\s*:\s*"[^"]*"' | head -1 | sed 's/"content"\s*:\s*"//;s/"$//' | sed 's/\\n/\n/g' 2>/dev/null || true)"
                if [[ -n "$text" ]]; then
                    echo -e "$text"
                fi
                ;;
            tool_use)
                local tool_name
                tool_name="$(echo "$line" | grep -oP '"name"\s*:\s*"[^"]*"' | head -1 | grep -oP '"[^"]*"$' | tr -d '"' 2>/dev/null || true)"
                if [[ -n "$tool_name" ]]; then
                    echo -e "${BLUE}[tool: ${tool_name}]${RESET}"
                fi
                ;;
            result)
                local result_text
                result_text="$(echo "$line" | grep -oP '"result"\s*:\s*"[^"]*"' | head -1 | sed 's/"result"\s*:\s*"//;s/"$//' | sed 's/\\n/\n/g' 2>/dev/null || true)"
                if [[ -n "$result_text" ]]; then
                    echo -e "${GREEN}${result_text}${RESET}"
                fi
                ;;
            "")
                # Not JSON or unrecognized â€” print raw
                echo "$line"
                ;;
        esac
    done < "$log_file"
}

cmd_logs() {
    if [[ -z "${TARGET_ID:-}" ]]; then
        echo "Usage: workmode sessions logs <session-id>" >&2
        exit 1
    fi

    local log_file
    log_file="$(find_session_log "$TARGET_ID")" || {
        echo "No log found for session '$TARGET_ID'." >&2
        echo "Logs are stored in: $LOG_DIR/" >&2
        exit 1
    }

    echo -e "${BOLD}Session: ${TARGET_ID}${RESET}"
    echo -e "Log file: ${log_file}"
    echo ""

    format_session_log "$log_file"
}

cmd_tail() {
    if [[ -z "${TARGET_ID:-}" ]]; then
        echo "Usage: workmode sessions tail <session-id>" >&2
        exit 1
    fi

    local log_file
    log_file="$(find_session_log "$TARGET_ID")" || {
        echo "No log found for session '$TARGET_ID'." >&2
        echo "Logs are stored in: $LOG_DIR/" >&2
        exit 1
    }

    echo -e "${BOLD}Tailing session: ${TARGET_ID}${RESET}"
    echo -e "Log file: ${log_file}"
    echo -e "(Ctrl+C to stop)"
    echo ""

    tail -f "$log_file"
}

# --- Dispatch ---
case "$COMMAND" in
    list)   cmd_list ;;
    logs)   cmd_logs ;;
    tail)   cmd_tail ;;
    resume) cmd_resume ;;
    *)      usage ;;
esac
