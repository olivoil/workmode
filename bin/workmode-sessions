#!/usr/bin/env bash
# workmode-sessions — List session history, filter, resume
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")/.." && pwd)"
source "$SCRIPT_DIR/lib/config.sh"
source "$SCRIPT_DIR/lib/sessions.sh"

STATE_DIR="$(config_state_dir)"
HISTORY_FILE="$STATE_DIR/history.jsonl"
LOG_DIR="$STATE_DIR/logs"

usage() {
    cat <<EOF
Usage: workmode-sessions [OPTIONS] [COMMAND]

Commands:
  list              List recent sessions (default)
  logs <id>         Show full output log of a session
  tail <id>         Follow a running session's log (like tail -f)
  resume <id>       Resume a session with claude --resume
  stop <id>         Gracefully stop a running session (SIGTERM)
  kill <id>         Force-kill a running session (SIGKILL)

Options:
  --running         Show only running sessions
  --stuck           Show only stuck sessions
  --completed       Show only completed sessions
  --all             Show all sessions (default: last 20)
  -n <count>        Number of sessions to show
  --json            Output raw JSON

EOF
    exit 0
}

# --- Parse args ---
FILTER=""
COUNT=20
COMMAND="list"
OUTPUT="table"

while [[ $# -gt 0 ]]; do
    case "$1" in
        resume)
            COMMAND="resume"
            shift
            RESUME_ID="${1:-}"
            shift || true
            ;;
        stop)
            COMMAND="stop"
            shift
            TARGET_ID="${1:-}"
            shift || true
            ;;
        kill)
            COMMAND="kill"
            shift
            TARGET_ID="${1:-}"
            shift || true
            ;;
        logs|log)
            COMMAND="logs"
            shift
            TARGET_ID="${1:-}"
            shift || true
            ;;
        tail)
            COMMAND="tail"
            shift
            TARGET_ID="${1:-}"
            shift || true
            ;;
        list)      COMMAND="list"; shift ;;
        --running)   FILTER="running"; shift ;;
        --stuck)     FILTER="stuck"; shift ;;
        --completed) FILTER="completed"; shift ;;
        --all)       COUNT=0; shift ;;
        -n)          COUNT="$2"; shift 2 ;;
        --json)      OUTPUT="json"; shift ;;
        --help|-h)   usage ;;
        *)
            # If it looks like a session ID (short or full), treat as logs
            if [[ "$1" =~ ^wm- ]] || [[ "$1" =~ ^[a-z]+-[0-9a-f]{4}$ ]]; then
                COMMAND="logs"
                TARGET_ID="$1"
                shift
            else
                echo "Unknown option: $1" >&2
                usage
            fi
            ;;
    esac
done

# --- Commands ---

cmd_list() {
    if [[ ! -f "$HISTORY_FILE" ]]; then
        echo "No sessions yet."
        exit 0
    fi

    local lines=()
    while IFS= read -r line; do
        lines+=("$line")
    done < <(tac "$HISTORY_FILE" | dedup_sessions "$FILTER" "$COUNT")

    if [[ ${#lines[@]} -eq 0 ]]; then
        echo "No sessions found${FILTER:+ with status '$FILTER'}."
        exit 0
    fi

    if [[ "$OUTPUT" == "json" ]]; then
        printf '%s\n' "${lines[@]}"
        return
    fi

    # Table header
    printf "${BOLD}%-10s %-14s %-14s %-10s %-14s %s${RESET}\n" \
        "STATUS" "TRIGGER" "STARTED" "DURATION" "ID" "SUMMARY"

    for line in "${lines[@]}"; do
        local status trigger started duration short_id full_id summary
        status="$(json_field "$line" "status")"
        trigger="$(json_field "$line" "trigger")"
        started="$(json_field "$line" "started")"
        duration="$(json_field_num "$line" "duration")"
        short_id="$(json_field "$line" "short")"
        [[ -z "$short_id" ]] && short_id="$(json_field "$line" "id")"
        full_id="$(json_field "$line" "id")"

        summary=""
        if [[ -f "$LOG_DIR/${full_id}.log" && -s "$LOG_DIR/${full_id}.log" ]]; then
            summary="$(extract_summary "$LOG_DIR/${full_id}.log" 50)"
        fi
        if [[ -z "$summary" ]]; then
            local error_hint
            error_hint="$(json_field "$line" "error")"
            if [[ -n "$error_hint" ]]; then
                summary="$error_hint"
                (( ${#summary} > 50 )) && summary="${summary:0:49}…"
            else
                local exit_code
                exit_code="$(json_field_num "$line" "exit_code")"
                if [[ -n "$exit_code" && "$exit_code" != "0" ]]; then
                    summary="exit code $exit_code"
                fi
            fi
        fi

        printf "%s %-14s %-14s %-10s %-14s %b%s%b\n" \
            "$(status_icon "$status")" \
            "$trigger" \
            "$(format_time "$started")" \
            "$(format_duration "$duration")" \
            "$short_id" \
            "$DIM" "$summary" "$RESET"
    done
}

cmd_resume() {
    if [[ -z "${RESUME_ID:-}" ]]; then
        echo "Usage: workmode sessions resume <id>" >&2
        exit 1
    fi

    local session_line
    session_line="$(resolve_session "$RESUME_ID" "$HISTORY_FILE")" || {
        echo "Session '$RESUME_ID' not found." >&2
        exit 1
    }

    local claude_session_id
    claude_session_id="$(json_field "$session_line" "session_id")"

    if [[ -z "$claude_session_id" ]]; then
        echo "No Claude session ID found for '$RESUME_ID'." >&2
        echo "The session may not have started successfully."
        exit 1
    fi

    # Resume must run from the same working directory as the original session
    local working_dir
    working_dir="$(json_field "$session_line" "working_dir")"
    if [[ -n "$working_dir" && -d "$working_dir" ]]; then
        echo "Resuming in: $working_dir"
        cd "$working_dir"
    fi

    echo "Resuming Claude session: $claude_session_id"
    exec claude --resume "$claude_session_id"
}

cmd_logs() {
    if [[ -z "${TARGET_ID:-}" ]]; then
        echo "Usage: workmode sessions logs <session-id>" >&2
        exit 1
    fi

    # Always show session metadata from history
    local session_line
    session_line="$(resolve_session "$TARGET_ID" "$HISTORY_FILE" 2>/dev/null || true)"

    if [[ -n "$session_line" ]]; then
        local full_id status trigger started duration exit_code attempt session_id working_dir
        full_id="$(json_field "$session_line" "id")"
        status="$(json_field "$session_line" "status")"
        trigger="$(json_field "$session_line" "trigger")"
        started="$(json_field "$session_line" "started")"
        duration="$(json_field_num "$session_line" "duration")"
        exit_code="$(json_field_num "$session_line" "exit_code")"
        attempt="$(json_field_num "$session_line" "attempt")"
        session_id="$(json_field "$session_line" "session_id")"
        working_dir="$(json_field "$session_line" "working_dir")"

        echo -e "${BOLD}Session: ${TARGET_ID}${RESET}"
        echo "Status:   $status"
        echo "Trigger:  $trigger"
        echo "Started:  $(format_time "$started")"
        [[ -n "$duration" && "$duration" != "0" ]] && echo "Duration: $(format_duration "$duration")"
        [[ -n "$working_dir" ]] && echo "Dir:      $working_dir"
        [[ -n "$session_id" ]] && echo "Claude:   $session_id"
        [[ -n "$exit_code" ]] && echo -e "Exit:     ${RED}${exit_code}${RESET}"
        [[ -n "$attempt" && "$attempt" != "1" ]] && echo "Attempt:  $attempt"
        echo ""
    else
        echo -e "${BOLD}Session: ${TARGET_ID}${RESET}"
        echo ""
    fi

    local log_file
    log_file="$(find_session_log "$TARGET_ID" "$LOG_DIR" "$HISTORY_FILE" 2>/dev/null || true)"

    if [[ -n "$log_file" && -s "$log_file" ]]; then
        echo -e "${DIM}─── Log output ───${RESET}"
        echo ""
        format_session_log "$log_file"
    elif [[ -n "$log_file" && -f "$log_file" ]]; then
        echo -e "${DIM}(log file is empty — session may have crashed before producing output)${RESET}"
    else
        echo -e "${DIM}(no log file found)${RESET}"
    fi
}

cmd_stop() {
    if [[ -z "${TARGET_ID:-}" ]]; then
        echo "Usage: workmode sessions stop <id>" >&2
        exit 1
    fi
    terminate_session "$TARGET_ID" "stop" "$HISTORY_FILE" "$STATE_DIR"
}

cmd_kill() {
    if [[ -z "${TARGET_ID:-}" ]]; then
        echo "Usage: workmode sessions kill <id>" >&2
        exit 1
    fi
    terminate_session "$TARGET_ID" "kill" "$HISTORY_FILE" "$STATE_DIR"
}

cmd_tail() {
    if [[ -z "${TARGET_ID:-}" ]]; then
        echo "Usage: workmode sessions tail <session-id>" >&2
        exit 1
    fi

    local log_file
    log_file="$(find_session_log "$TARGET_ID" "$LOG_DIR" "$HISTORY_FILE")" || {
        echo "No log found for session '$TARGET_ID'." >&2
        echo "Logs are stored in: $LOG_DIR/" >&2
        exit 1
    }

    echo -e "${BOLD}Tailing session: ${TARGET_ID}${RESET}"
    echo -e "Log file: ${log_file}"
    echo -e "(Ctrl+C to stop)"
    echo ""

    tail -f "$log_file"
}

# --- Dispatch ---
case "$COMMAND" in
    list)   cmd_list ;;
    logs)   cmd_logs ;;
    tail)   cmd_tail ;;
    resume) cmd_resume ;;
    stop)   cmd_stop ;;
    kill)   cmd_kill ;;
    *)      usage ;;
esac
